Package sc;

Helpers

lettre = [['a' .. 'z'] + ['A' .. 'Z']];

Tokens

espaces = (' ' | 13 | 10)+;
commentaire= '#' [[0 .. 0xffff] - [10 + 13]]* (10 | 13 | 10 13);

parenthese_ouvrante = '(' ;
parenthese_fermante = ')' ;
accolade_ouvrante = '{';
accolade_fermante = '}';
crochet_ouvrant = '[';
crochet_fermant =  ']';

egale = '=' ;
et = '&' ;
ou = '|' ;
inferieur = '<';
addition = '+' ;
soustraction = '-' ;
multiplication = '*' ;
division = '/';
mod = '%' ;
non_logique = '!';

virgule = ',';
point_virgule = ';' ;

si = 'si' ;
alors = 'alors';
sinon = 'sinon';

tant_que_logique = 'tantque' ;
faire = 'faire';

type = 'entier';


lire = 'lire';
ecrire = 'ecrire';
retourner = 'retourner';
main = 'main';

chiffre = ['0' .. '9']+;

nom = lettre lettre*;

Ignored Tokens

espaces,commentaire;

Productions

programme = optdecvar listedecfonc ;

optdecvar =
    {decla_glob} decla_variable |
    {vide};

listedecfonc =
    {main_fnc} main_fonc|
    {autre_fnc} fonction listedecfonc;

main_fonc =
    {main} main parenthese_ouvrante parenthese_fermante optdecvar bloc_inst ;

list_expr =
    {expr} expr sous_list_expr |
    {vide};

sous_list_expr =
    {list_expr} virgule expr sous_list_expr |
    {vide};

expr =
    {exp1} exp1 |
    {ou} expr ou exp1 ;

exp1 =
    {exp2} exp2 |
    {et} exp1 et exp2 ;

exp2 =
    {exp3} exp3 |
    {egale} exp2 egale exp3 |
    {inferieur} exp2 inferieur exp3;

exp3 =
    {exp4} exp4 |
    {addition} exp3 addition exp4 |
    {soustraction} exp3 soustraction exp4;

exp4 =
    {exp5} exp5 |
    {multiplication} exp4 multiplication exp5 |
    {division} exp4 division exp5 ;

exp5 =
    {exp6} exp6 |
    {non_logique} non_logique parenthese_ouvrante exp6 parenthese_fermante ;

exp6 =
    {parenthese} parenthese_ouvrante expr parenthese_fermante |
    {nombrer} nombre |
    {apl_fonc} apl_fonc |
    {variable} variable ;

nombre =
    {chiffres} chiffre nombre|
    {chiffre} chiffre ;

instruction =
    {affect} variable egale expr point_virgule|
    {if} si expr alors bloc_inst compl |
    {while} tant_que_logique expr faire bloc_inst |
    {return} retourner parenthese_ouvrante expr parenthese_fermante point_virgule |
    {apl_fonc} apl_fonc point_virgule|
    {block_instructions} bloc_inst ;

compl =
    {decla_si_sinon} sinon bloc_inst |
    {vide};

bloc_inst =
    {bloque} accolade_ouvrante list_inst accolade_fermante ;

list_inst =
    {list} instruction sous_list_inst |
    {vide};

sous_list_inst =
    {sous_list} instruction sous_list_inst |
    {vide};

decla_variable =
    {declaration} type variable point_virgule |
    {decla_suiv} type variable virgule decla_variable |
    {decla_seule} type variable ;

variable =
    {var} nom |
    {tab} nom crochet_ouvrant nombre crochet_fermant;

fonction =
    {decla_fnc} nom parenthese_ouvrante decla_variable parenthese_fermante optdecvar bloc_inst ;

apl_fonc =
    {decla_apl_fonc} nom parenthese_ouvrante list_expr parenthese_fermante |
    {lec} lecture |
    {ecr} ecriture;

lecture =
    {decla_lec} lire parenthese_ouvrante parenthese_fermante;

ecriture =
    {decla_ecri} ecrire parenthese_ouvrante expr parenthese_fermante;